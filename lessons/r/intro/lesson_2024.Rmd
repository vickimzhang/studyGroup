---
title: "Intro R"
author: "Vicki"
date: "10/9/2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Welcome

 - **Authors**: Vicki Z., adapted from Ahmed Hassan, Margot Lautens. and Luke Johnston
 - **Research field**: Ecology and Evolutionary Biology
 - **Lesson topic**: Intro to R, some data wrangling, statistics, and some visualization
 - **Lesson content URL**: <https://github.com/UofTCoders/studyGroup/tree/gh-pages/lessons/r/intro>

# Why should we use R? 
- reproducible science 
- wonderful packages to help you for working with your data (even datasets that are very big)!
- packages specific to disciplines: biology, genetics, even neuroimaging
- can customize and create reports with RMarkdown. 

# What can we do with R? 
- Organize: Tidy data
- Analyze: statistics, machine learning, field-specific techniques
- Visualize

# Starting with R - the command line

## Command Line

The command line executes code like a calculator but does not keep a record of your work. 
Try entering 2+2 in the commandline, what is the output? 

Now lets save 4 as a variable a. The way we do this in R is typing `a <- 4` in the command line. Here the `<-` is acting as an = sign. 

In summary, you can execute code in the command line, but you will need to scroll back to see the previous code you executed. To reproduce your code, you will need to create a script. 

## Scripts
The type of script we are working in is called and .Rmd file it is an R Markdown script. THis script is helpful for building reports which can later be rendered as a pdf or html file. 

Below is a `code chunk`, where you keep a record of your code and you can execute that code. Anything outside of the code can be used as text to supplement your report or write notes about your process. You can open a code chunk using the `Insert` button or using the short cut for your device. 

Try running the code chunk below by pressing the green play button. 
```{r}
# this is a comment, this will not run as code. 
# Assign the value of 4 to variable "a"
a <- 4
# return the value of a
print(a)
# Ask r if 2+2 is equal to "a"
2 + 2 == a
```

## Other windows in R
- Environment: all the variables we have saved, our functions, and libraries we have loaded
- History
- Files
- Help 

# Starting your script
1. Set our "working directory", this means we are telling R where to take files from and where to write them. 
2. Load in the packages we need to use for our project. 
If we don't have the package installed already, you will use the `install.packages` function.
Whether you have the package or not, you will load the package using the `library` function.
```{r}
# Load in the tidyverse and Using R libraries
library(tidyverse)
library(UsingR)
```

3. Load in our data.
We will be using a dataset that is already in R, so lets take a look at `surveys` and try to store as variable `df` in our environment.
```{r}
# call the surveys dataset
# download.file("https://ndownloader.figshare.com/files/2292169", "portal_data.csv")
library(readr)
surveys <- read_csv("portal_data.csv")
```

Now if we call df, we can see we have the surveys dataset 
```{r}
# viewing df
View(surveys)
# OR
surveys
```

Lets use the function write.csv to take that data and save it as a .csv file in our current directory

```{r}
write.csv(surveys, "surveys.csv")
```

A few ways to lad data are to:
- manually use the import dataset button in Rstudio (and copy the code from the output)
- use `read_csv()` function from readr package
```{r}
# copy the code generated by the import dataset button
library(readr)
surveys <- read_csv("portal_data.csv")
View(surveys)
```

# Viewing the data and its structure

1. Instead of viewing the whole dataset we can use the `head` function to view the first 6 rows of the data. 
2. If you want to view more rows of data, use the argument n= to change the size of the table returned. 
```{r}
# view the whole dataset
View(surveys)
# use the head function to view the first 6 rows of the data
head(surveys)
# Look at the first 10 rows of the data
head(surveys, n=10)
```

3. Another important function is `str` it returns the structure of the object. For a `data.frame` that we have here, it will also give you the column names and the structure of those columns. 
`dim` is also a useful function that will retrun the dimesnions of your data.frame.
`names()` shows the column names.
`glimpse()` is a `dplyr` only function that ressembles `str` but unlike `str`
it allows you to see all your columns.
`row.names()` or `rownames()` will return a vector of the rownames of the dataset. However, only `rownames()`can be changed, we will return to the uses of this function later. 

```{r}
# use the str() function on df
str(surveys)
# use the dim() function to return the size of df
dim(surveys)
# use names() to return the column names
names(surveys)
# use row.names() or rownames() to return a vector of the rownames
row.names(surveys)
```

#Summary statistics and exploring patterns

1. `summary()` shows a quick description of the summary statistics (means, 
median, frequency)for each of your columns.  

This function is especially useful for finding issues in the data coding and in the data structure.
For example, look at the variable sex - is there is something strange here?
Are there any other variables that might have issues?
These are all issues we can fix when we tidy the data, we will return to data tidying in the next section. 
```{r}
# give a summary of df
summary(surveys)
```

2. Plotting to explore the data

Before we plot any of the columns, we need to know how to select columns from the dataset. 
To call a column of the data we can use the $ operator: df$sex will give us the sex column. 
With dataframes, we can call specific rows and collumns using the index. For example with df[1,6], will give us the 1st row and the 6th column. We can also select a range of columns or rows using `:` operator. 

```{r}
# Try calling the hindfoot_length column using the `$`
surveys$hindfoot_length
# Try another way to get the hindfoot_length column
surveys[, 8]
# Try to get the first ten rows of the weight column
surveys[1:10, 8]
```


2. There are some base functions that allow us to visualize our data:
`hist()` will provide a historgram of a variable.
`plot()` can allow you to compare two variables, x and y, in many different types of plots. 

```{r}
# Try plotting wt as a histogram
hist(surveys$hindfoot_length)
# try plotting ht as the x variable and wt as the y variable
plot(x = surveys$hindfoot_length, y = surveys$weight)
# Now lets use the help function ? to view the plot function
?plot
# Lets try changing the type argument
plot(x = surveys$hindfoot_length, y = surveys$weight, type = "l")
```

#Introduction to data tidying and tidyverse

1. When we looked at the `summary()` of our data, we found that some variables were coded as numeric, when they should be binary or categorical (factors).
`as.logical()` will transform the variable into a logical `TRUE` or `FALSE`
`as.numeric()` will transform the variable into a numeric variable
`as.character()` will transform the variable into character strings
`as.factor()` will transform the variable into a factor. However, the levels will be created automatically and might not be the correct order. You might want to use `factor()` to change the variable. 

```{r}
library(tidyverse)
# lets take a look at the summary again
summary(surveys)

# let's look at what the coding should be for the variables in this dataset by looking at the data key
?surveys

# Sex is a factor with 3 levels, 1,2,9
as.factor(surveys$sex)

# only one level is showing, let's use factor() to and set levels = c("1","0")
factor(surveys$sex, levels = c("1", "2", "9"))

# now we have to save our new variable 
surveys$sex <- factor(surveys$sex, levels = c("1", "2", "9"))
```

Try it yourself:
1. check the data key on the surveys data set using ?surveys and look at the variable marital
2. change the variable genus to a character 
3. look at the summary of genus as a character variable
4. now change genus to a factor
5. look at the summary of geus as a factor, what is the difference between the summary if genus is a character or a factor?
```{r}

```


# Introduction to Tidyverse

Data wrangling is a bit tedious in base R. At the beginning of the session we loaded in a great collection of packages, `tidyverse` designed to make this easier.  Load packages by using the `library()`
function.  `dplyr` allows for easy manipulation of datasets.

`select` is a `dplyr` function that lets us select columns from the dataset. 

Columns can be selected individually with `,`, in a series with `:` or removed with `-`.
```{r wrangleSelect}
# The first two  lines of code are the same. 
dplyr::select(surveys, plot_id, species_id, weight, year)

# This line of code selects the first 3 columns
dplyr::select(surveys, 1:3)
```


`filter` is a `dplyr` function that lets us choose rows based on a specific criteria. Note the double equal sign `==` for testing if `year` is equal to 1995  A single `=` is
used for something else (assigning things to objects). Use `&` or `,` to apply multiple filters.
```{r}
filter(surveys, "year" == 1995)
filter(surveys, "year" == 1995 | 1977)
```


`dplyr` also comes with a `%>%` pipe function (via the
`magrittr` package), which works similar to how the Bash shell `|`
pipe works. The command on the right-hand side takes the output from
the command on the left-hand side, just like how a plumbing pipe works
for water. The `.` object represents the output from the pipe, but it 
doesn't have to be used as using `%>%` implies also using `.`.

This means that we can select and filter at the same time!

```{r wranglePipe}
# The outputs of each of these two lines of code are the same. 
surveys %>%
  select(., plot_id, species_id, weight, year) %>%
  filter(., year == 1995)
```

You can rename columns either using `rename` or `select` (the new name
is on the left hand side, so `newname = oldname`).  However, with the
`select` command, only that column gets selected, while `rename`
selects all columns.

```{r wrangleRename}
surveys %>%
  rename(length = hindfoot_length)
```


`mutate` creates a new column. 

```{r wrangleChain}
surveys %>%
    mutate(weight_kg = weight / 1000)
```

We can start chaining these commands together using the `%>%` command.
There is no limit to how long a chain can be. The first few rows of the output are full of NAs, so if we wanted to remove those we could insert a filter() in the chain:

```{r}
surveys %>%
  filter(!is.na(weight)) %>%
  mutate(weight_kg = weight / 1000)
```

Combined with `dplyr`'s `group_by` and `summarise` you can quickly
summarise data or do further, more complicated analyses. `group_by`
makes it so further analyses or operations work on the groups.
`summarise` transforms the data to only contain the new variable(s)
created, in this case the mean. You can try out `max()`,`min()`,`median()` and `sd()`.

```{r reorgChain}
surveys %>%
  filter(!is.na(hindfoot_length) & !is.na(weight)) %>%
  group_by(species) %>%
  tally() %>%
  arrange(desc(n))
```


# Introduction to ggplot
ggplot2 is a plotting package that makes it simple to create complex plots from data frames. The name ggplot2 comes from its inspiration, the book “A grammar of graphics”, and the main goal is to allow coders to express their desired outcome on a high level instead of telling the computer every detail about what will happen. For example, you would say “color my data by species” instead of “go through this data frame and plot any observations of species1 in blue, any observations of species2 in red, etc”. Thanks to this functional way of interfaces with data, only minimal changes are required if the underlying data change or to change the type of plot. This helps in thinking about the data and creating publication quality plots with minimal amounts of adjustments and tweaking.

ggplot graphics are built step by step by adding new elements, or layers. Adding layers in this fashion allows for extensive flexibility and customization of plots. To build a ggplot, we need to:

1. Use the ggplot() function and bind the plot to a specific data frame using the data argument
```{r}
ggplot(data = surveys)
```

2. Define aesthetics (aes), by selecting the variables to be plotted and the variables to define the presentation such as plotting size, shape color, etc.
```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length))
```

3. Add geoms – geometrical objects as a graphical representation of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use a few common ones today, including:
`geom_point()` for scatter plots, dot plots, etc.
`geom_line()` for trend lines, time-series, etc.
`geom_histogram()` for histograms

To add a geom to the plot use + operator. Because we have two continuous variables, let’s use `geom_point()` first:
```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
  geom_point()
```

## Buiding plots iteratively

Building plots with ggplot is typically an iterative process. We start by defining the dataset we’ll use, lay the axes, and choose a geom:

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
  geom_point()
```


Then, we start modifying this plot to extract more information from it. For instance:
- we can add transparency (alpha) to reduce overplotting
- we can colour the data points according to a categorical variable is an easy way to find out if there seems to be correlation

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length, colour = plot_type)) +
  geom_point()
```


…and it turns out that only rodents, have had their hindfeet measured!

Let’s remove all animals that did not have their hindfeet measured, including those rodents that did not. Animals without their weight measured will also be removed.

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length, colour = genus)) +
  geom_point()
```

## Bringing it all together

Let’s include only those with more than 800 observations, and remove all of the NAs. We'll also group by species, as we can see that there is some separation based on species.

```{r}
surveys %>%
  filter(!is.na(hindfoot_length) & !is.na(weight)) %>%
  group_by(species) %>%
  mutate(n = n()) %>% # add count value to each row
  filter(n > 800) %>%
  select(-n) %>%
  ggplot(aes(x = weight, y = hindfoot_length, colour = species)) +
    geom_point(alpha = 0.2)
```


# show how to knit using knit button
 maybe errors